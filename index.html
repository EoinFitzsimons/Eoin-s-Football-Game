<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Football Game</title>
<<<<<<< Updated upstream
<<<<<<< Updated upstream
    <link rel="stylesheet" href="assets/style.css">
    <!-- Three.js ES Modules via CDN using import maps -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/GLTFLoader.js"
      }
    }
    </script>
</head>
<body>
=======
    <link rel="stylesheet" href="assets/style.css" />
  </head>
  <body>
>>>>>>> Stashed changes
=======
    <link rel="stylesheet" href="assets/style.css" />
  </head>
  <body>
>>>>>>> Stashed changes
    <h1>Football Game</h1>
    <div id="scoreboard">
      <div id="scoreline" class="scoreline">
        <span class="score-user">You</span>
        <span id="score-user">0</span>
        <span class="score-separator">-</span>
        <span id="score-cpu">0</span>
        <span class="score-cpu">CPU</span>
      </div>
      <span id="info">Time: <b>90</b>s</span>
      <span id="debug"></span>
    </div>
    <div id="overlay"></div>
    <button id="replayBtn">Replay</button>
    <button id="muteBtn">ðŸ”Š</button>
    <div id="help">
      Controls: Arrow keys/WASD = Move | Space = Pass / Shoot / Tackle | R =
      Replay | M = Mute
    </div>
    <div id="powerbar-container">
      <div id="powerbar-bg"></div>
      <div id="powerbar-fill"></div>
      <div id="powerbar-label">Power</div>
    </div>
    <script type="module">
<<<<<<< Updated upstream
<<<<<<< Updated upstream
    // --- 3D Football Game (modular, extensible, ~2000 lines) ---
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
=======
      // 3D Football Game using Three.js
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js";
>>>>>>> Stashed changes
=======
      // 3D Football Game using Three.js
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js";
>>>>>>> Stashed changes

      // --- Utility Functions ---
      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      function randRange(a, b) {
        return a + Math.random() * (b - a);
      }

<<<<<<< Updated upstream
<<<<<<< Updated upstream
    // --- Game Constants ---
    const FIELD_LENGTH = 160;
    const FIELD_WIDTH = 80;
    const GOAL_WIDTH = 24;
    const GOAL_DEPTH = 8;
    const GOAL_HEIGHT = 8; // Added missing constant
    const PLAYER_RADIUS = 3;
    const PLAYER_HEIGHT = 8;
    const BALL_RADIUS = 2.2;
const TEAM_SIZE = 3;
    const GAME_TIME = 90; // seconds
    const REPLAY_FRAMES = 300; // 5s at 60fps

    // --- Game Classes ---
    class Game {
        // Handles key up events
        onKeyUp(e) {
            this.debugFunctionEntry('onKeyUp', { key: e.key });
            this.controls[e.key.toLowerCase()] = false;
        }
        // Draws player labels (stub for now)
        drawLabels() {
            // Highlight selected player with a ring
            for (let [i, player] of this.teams[0].players.entries()) {
                if (!player.highlightRing) {
                    const ringGeom = new THREE.TorusGeometry(PLAYER_RADIUS+1.2, 0.5, 8, 32);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const ring = new THREE.Mesh(ringGeom, ringMat);
                    ring.position.y = 0.5;
                    player.mesh.add(ring);
                    player.highlightRing = ring;
                }
                player.highlightRing.visible = (i === this.selectedPlayerIdx);
            }
        }
        // Resets all player positions to their starting locations
        resetPositions() {
            // User team
            this.teams[0].resetPositions(-FIELD_LENGTH/2 + 18);
            // CPU team
            this.teams[1].resetPositions(FIELD_LENGTH/2 - 18 - (TEAM_SIZE-1)*8);
            // Ball in center
            this.ball.setPosition(0, this.ball.mesh.position.y, 0);
            this.ball.velocity.set(0,0,0);
        }
        // --- Weather Effects ---
        initWeather() {
            // Randomly pick weather: 'clear', 'rain', 'snow', 'fog'
            const weathers = ['clear', 'rain', 'snow', 'fog'];
            this.weather = weathers[Math.floor(Math.random() * weathers.length)];
            // Add weather indicator
            let indicator = document.createElement('div');
            indicator.id = 'weather-indicator';
            indicator.style.position = 'fixed';
            indicator.style.top = '12px';
            indicator.style.right = '24px';
            indicator.style.zIndex = '9999';
            indicator.style.fontSize = '1.2em';
            indicator.style.color = '#fff';
            indicator.style.textShadow = '1px 1px 6px #000';
            indicator.style.background = 'rgba(30,40,60,0.7)';
            indicator.style.padding = '8px 18px';
            indicator.style.borderRadius = '12px';
            indicator.innerHTML = `Weather: <b>${this.weather.charAt(0).toUpperCase() + this.weather.slice(1)}</b>`;
            document.body.appendChild(indicator);

            // Add visual effects
            if (this.weather === 'rain') this.addRain();
            if (this.weather === 'snow') this.addSnow();
            if (this.weather === 'fog') this.addFog();
        }

        addRain() {
            // Simple rain particle system
            const rainCount = 180;
            this.rainDrops = [];
            for (let i = 0; i < rainCount; ++i) {
                let drop = document.createElement('div');
                drop.className = 'rain-drop';
                drop.style.position = 'fixed';
                drop.style.left = Math.random()*100 + 'vw';
                drop.style.top = Math.random()*100 + 'vh';
                drop.style.width = '2px';
                drop.style.height = (8+Math.random()*12) + 'px';
                drop.style.background = 'rgba(180,220,255,0.7)';
                drop.style.borderRadius = '1px';
                drop.style.zIndex = '9998';
                drop.style.pointerEvents = 'none';
                document.body.appendChild(drop);
                this.rainDrops.push(drop);
            }
            // Animate rain
            setInterval(() => {
                for (let drop of this.rainDrops) {
                    let top = parseFloat(drop.style.top);
                    top += 2 + Math.random()*3;
                    if (top > 100) top = -Math.random()*10;
                    drop.style.top = top + 'vh';
                }
            }, 40);
        }

        addSnow() {
            // Simple snow particle system
            const snowCount = 120;
            this.snowFlakes = [];
            for (let i = 0; i < snowCount; ++i) {
                let flake = document.createElement('div');
                flake.className = 'snow-flake';
                flake.style.position = 'fixed';
                flake.style.left = Math.random()*100 + 'vw';
                flake.style.top = Math.random()*100 + 'vh';
                flake.style.width = (3+Math.random()*3) + 'px';
                flake.style.height = flake.style.width;
                flake.style.background = 'rgba(255,255,255,0.85)';
                flake.style.borderRadius = '50%';
                flake.style.zIndex = '9998';
                flake.style.pointerEvents = 'none';
                document.body.appendChild(flake);
                this.snowFlakes.push(flake);
            }
            // Animate snow
            setInterval(() => {
                for (let flake of this.snowFlakes) {
                    let top = parseFloat(flake.style.top);
                    top += 1 + Math.random()*1.5;
                    if (top > 100) top = -Math.random()*10;
                    flake.style.top = top + 'vh';
                    let left = parseFloat(flake.style.left);
                    left += Math.random()*0.8-0.4;
                    if (left > 100) left = 0;
                    if (left < 0) left = 100;
                    flake.style.left = left + 'vw';
                }
            }, 60);
        }

        addFog() {
            // Add fog overlay
            let fog = document.createElement('div');
            fog.id = 'fog-overlay';
            fog.style.position = 'fixed';
            fog.style.left = '0';
            fog.style.top = '0';
            fog.style.width = '100vw';
            fog.style.height = '100vh';
            fog.style.background = 'radial-gradient(circle at 50% 60%, rgba(200,200,220,0.22) 0%, rgba(200,200,220,0.12) 60%, rgba(200,200,220,0.04) 100%)';
            fog.style.zIndex = '9997';
            fog.style.pointerEvents = 'none';
            document.body.appendChild(fog);
        }
        // Debug: log function entry with arguments, one message per function per interval
        debugFunctionEntry(name, args) {
            let argStr = '';
            if (args && typeof args === 'object') {
                try {
                    argStr = Object.entries(args).map(([k, v]) => {
                        if (typeof v === 'object' && v !== null && 'x' in v && 'z' in v) {
                            // Avoid nested template literals
                            let x = v.x && typeof v.x.toFixed === 'function' ? v.x.toFixed(2) : v.x;
                            let z = v.z && typeof v.z.toFixed === 'function' ? v.z.toFixed(2) : v.z;
                            return k + '=' + '(' + x + ',' + z + ')';
                        }
                        return k + '=' + v;
                    }).join(', ');
                } catch (e) {
                    console.error('debugFunctionEntry error:', e);
                    argStr = '[args error]';
                }
            }
            this.logDebug('[FUNC] ' + name + '(' + argStr + ')', name);
=======
      // --- Game Constants ---
      const FIELD_LENGTH = 105; // Standard football pitch length (meters)
      const FIELD_WIDTH = 68;  // Standard football pitch width (meters)
      const GOAL_WIDTH = 7.32; // Standard goal width (meters)
      const GOAL_DEPTH = 2.44; // Standard goal depth (meters)
      const PLAYER_RADIUS = 1.2;
      const PLAYER_HEIGHT = 1.8;
      const BALL_RADIUS = 0.22;
      const TEAM_SIZE = 11;
      const GAME_TIME = 90 * 60; // 90 minutes in seconds
      const REPLAY_FRAMES = 18000; // 5 minutes at 60fps
      const GOAL_HEIGHT = 2.44; // Standard goal height (meters)

=======
      // --- Game Constants ---
      const FIELD_LENGTH = 105; // Standard football pitch length (meters)
      const FIELD_WIDTH = 68;  // Standard football pitch width (meters)
      const GOAL_WIDTH = 7.32; // Standard goal width (meters)
      const GOAL_DEPTH = 2.44; // Standard goal depth (meters)
      const PLAYER_RADIUS = 1.2;
      const PLAYER_HEIGHT = 1.8;
      const BALL_RADIUS = 0.22;
      const TEAM_SIZE = 11;
      const GAME_TIME = 90 * 60; // 90 minutes in seconds
      const REPLAY_FRAMES = 18000; // 5 minutes at 60fps
      const GOAL_HEIGHT = 2.44; // Standard goal height (meters)

>>>>>>> Stashed changes
      // --- Game Classes ---
      class Game {
        constructor() {
          this.debugFunctionEntry("constructor");
          this.lastFrameTime = null;
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(0, 160, 180); // Raise camera for better view
          this.camera.lookAt(0, 0, 0);
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x1e824c);
          this.renderer.shadowMap.enabled = true;
          document.body.appendChild(this.renderer.domElement);
          window.addEventListener("resize", () => this.onWindowResize());

          // Lighting
          this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(0, 120, 100);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 1024;
          dirLight.shadow.mapSize.height = 1024;
          dirLight.shadow.camera.near = 10;
          dirLight.shadow.camera.far = 300;
          dirLight.shadow.camera.left = -100;
          dirLight.shadow.camera.right = 100;
          dirLight.shadow.camera.top = 100;
          dirLight.shadow.camera.bottom = -100;
          this.scene.add(dirLight);

          // Field
          this.field = new Field(this.scene);

          // Ball
          this.ball = new Ball(this.scene);

          // Teams
          this.teams = [
            new Team(this.scene, 0, 0xf39c12, "You"),
            new Team(this.scene, 1, 0xe74c3c, "CPU"),
          ];
          this.teams[0].isUser = true;
          this.teams[1].isUser = false;

          // Game State
          this.score = [0, 0];
          this.time = GAME_TIME;
          this.state = "playing"; // Only use 'playing', 'goal', 'end', 'replay', 'out', 'throw-in'
          this.lastGoalTeam = null;
          this.selectedPlayerIdx = 0;

          // Controls
          this.controls = {};
          document.addEventListener("keydown", (e) => this.onKeyDown(e));
          document.addEventListener("keyup", (e) => this.onKeyUp(e));

          // Sound
          this.sounds = this.initSounds();
          this.muted = false;
          document.getElementById("muteBtn").onclick = () => this.toggleMute();

          // Replay
          this.replayBuffer = [];
          this.isReplaying = false;
          document.getElementById("replayBtn").onclick = () =>
            this.startReplay();

          // UI
          this.updateUI();
          // Start in 'playing' state, nudge ball, hide overlay, allow movement from frame 1
          this.resetPositions();
          let user = this.teams[0].players[0];
          let kickoffPos = user.mesh.position
            .clone()
            .add(new THREE.Vector3(PLAYER_RADIUS + BALL_RADIUS + 0.5, 0, 0));
          this.ball.setPosition(
            kickoffPos.x,
            this.ball.mesh.position.y,
            kickoffPos.z
          );
          this.ball.velocity.set(8, 0, 0); // gentle nudge forward
          this.state = "playing";
          this.hideOverlay();
          if (this.sounds.melody) this.sounds.melody.play();
          this.lastFrame = performance.now();
          this.animate();
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
        }

        animate() {
          // Use requestAnimationFrame for smooth rendering
          requestAnimationFrame(() => this.animate());
          // Calculate time delta
          const now = performance.now();
          this.lastFrameTime = this.lastFrameTime || now;
          const dt = Math.min((now - this.lastFrameTime) / 1000, 0.05); // cap delta for safety
          this.lastFrameTime = now;
          // Update game logic
          this.handleInput(dt);

          // Update ball physics
          if (this.ball && typeof this.ball.update === "function") {
            this.ball.update();
          }
          // Update all players
          if (this.teams) {
            for (const team of this.teams) {
              for (const player of team.players) {
                if (player && typeof player.update === "function") {
                  player.update();
                }
              }
            }
          }
          // Ball-player collision
          this._handlePlayerBallCollisions();
          // CPU AI movement
          this._handleCPUMovement(dt);
          // Goal and pitch boundary logic
          this._handleGoalAndBoundaries();

          // Render the scene
          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
          // Update UI
          this.updateUI();
        }
        // Handle goals and pitch boundaries
        _handleGoalAndBoundaries() {
          // Ball position
          const ball = this.ball.mesh.position;
          // Goal detection
          // User goal (left)
          if (
            ball.x < -FIELD_LENGTH / 2 + GOAL_DEPTH &&
            Math.abs(ball.z) < GOAL_WIDTH / 2 &&
            ball.y < GOAL_HEIGHT
          ) {
            this._scoreGoal(1); // CPU scores
            return;
          }
          // CPU goal (right)
          if (
            ball.x > FIELD_LENGTH / 2 - GOAL_DEPTH &&
            Math.abs(ball.z) < GOAL_WIDTH / 2 &&
            ball.y < GOAL_HEIGHT
          ) {
            this._scoreGoal(0); // User scores
            return;
          }
          // Pitch boundaries (bounce or reset)
          // Side boundaries (left/right)
          if (ball.x < -FIELD_LENGTH / 2 + BALL_RADIUS) {
            ball.x = -FIELD_LENGTH / 2 + BALL_RADIUS;
            this.ball.velocity.x *= -0.7;
          }
          if (ball.x > FIELD_LENGTH / 2 - BALL_RADIUS) {
            ball.x = FIELD_LENGTH / 2 - BALL_RADIUS;
            this.ball.velocity.x *= -0.7;
          }
          // End boundaries (top/bottom)
          if (ball.z < -FIELD_WIDTH / 2 + BALL_RADIUS) {
            ball.z = -FIELD_WIDTH / 2 + BALL_RADIUS;
            this.ball.velocity.z *= -0.7;
          }
          if (ball.z > FIELD_WIDTH / 2 - BALL_RADIUS) {
            ball.z = FIELD_WIDTH / 2 - BALL_RADIUS;
            this.ball.velocity.z *= -0.7;
          }
        }

        // Score a goal for teamIdx (0=user, 1=cpu)
        _scoreGoal(teamIdx) {
          this.score[teamIdx]++;
          this.lastGoalTeam = teamIdx;
          this.state = "goal";
          if (this.sounds.goal) this.sounds.goal.play();
          this.showOverlay((teamIdx === 0 ? "You" : "CPU") + " scored!");
          setTimeout(() => {
            this.hideOverlay();
            this.resetPositions();
            this.state = "playing";
          }, 1800);
        }
        // Ball-player collision: ball bounces off players

        // Basic AI movement for CPU team

        debugFunctionEntry(name, args) {
          let argStr = "";
          if (args && typeof args === "object") {
            try {
              argStr = Object.entries(args)
                .map(([k, v]) => {
                  if (
                    typeof v === "object" &&
                    v !== null &&
                    "x" in v &&
                    "z" in v
                  ) {
                    // Avoid nested template literals
                    let x =
                      v.x && typeof v.x.toFixed === "function"
                        ? v.x.toFixed(2)
                        : v.x;
                    let z =
                      v.z && typeof v.z.toFixed === "function"
                        ? v.z.toFixed(2)
                        : v.z;
                    return k + "=" + "(" + x + "," + z + ")";
                  }
                  return k + "=" + v;
                })
                .join(", ");
            } catch (e) {
              console.error("debugFunctionEntry error:", e);
              argStr = "[args error]";
            }
          }
          this.logDebug("[FUNC] " + name + "(" + argStr + ")", name);
        }
        // Debug helper: buffers debug messages, flushes to browser console every 3 seconds
        logDebug(msg, tag) {
          if (!this._debugBuffer) this._debugBuffer = {};
          if (!this._lastDebugTime) this._lastDebugTime = 0;
          const now = performance.now();
          // Only keep one message per tag per frame
          if (!tag) tag = "misc";
          this._debugBuffer[tag] = msg;
          // Only flush once per second
          if (now - this._lastDebugTime > 1000) {
            const messages = Object.values(this._debugBuffer);
            if (messages.length > 0) {
              console.group("[Game Debug]");
              messages.forEach((m) => console.debug(m));
              console.groupEnd();
            }
            this._debugBuffer = {};
            this._lastDebugTime = now;
          }
        }
        // --- Game State ---

        // Helper for try/catch blocks
        safe(fn, fallback) {
          try {
            return fn();
          } catch (e) {
            console.error(e);
            return fallback;
          }
        }

        // Power Bar Action Handler
        handlePowerBarAction() {
          this.debugFunctionEntry("handlePowerBarAction", {
            selectedPlayerIdx: this.selectedPlayerIdx,
          });
          this.logDebug("handlePowerBarAction called", "handlePowerBarAction");
          let player = this.teams[0].players[this.selectedPlayerIdx];
          const distToBall = player.mesh.position.distanceTo(this.ball.mesh.position);
          const canKick = distToBall < PLAYER_RADIUS + BALL_RADIUS + 2;
          let cpuTeam = this.teams[1];
          let cpuIdx = this._getClosestCPUPlayerIdx();
          let cpu = cpuTeam.players[cpuIdx];
          if (canKick && cpuIdx !== null && this._cpuDist < distToBall + 0.5) {
            this._handleTackle(player, cpu);
            return;
          }
          if (canKick) {
            this._handleKickOrPass(player, distToBall);
          }
        }

        _getClosestCPUPlayerIdx() {
          let cpuTeam = this.teams[1];
          let cpuIdx = null,
            cpuDist = Infinity;
          for (let i = 0; i < TEAM_SIZE; ++i) {
            let d = cpuTeam.players[i].mesh.position.distanceTo(
              this.ball.mesh.position
            );
            if (d < cpuDist) {
              cpuDist = d;
              cpuIdx = i;
            }
          }
          this._cpuDist = cpuDist; // Store for use in handlePowerBarAction
          return cpuIdx;
        }

        _handleTackle(player, cpu) {
          let tackleDir = new THREE.Vector3()
            .subVectors(player.mesh.position, cpu.mesh.position)
            .normalize();
          this.ball.velocity.addScaledVector(tackleDir, 18);
          this.ball.spin += randRange(-0.12, 0.12);
          player.cooldown = 0.18;
          cpu.cooldown = 0.7;
          cpu._tackledTimer = 0.7;
          if (this.sounds.kick) this.sounds.kick.play();
        }

        _handleKickOrPass(player, distToBall) {
          // Show power bar UI
          this._showPowerBarUI();
          // Direction from player to ball
          let toBall = new THREE.Vector3().subVectors(this.ball.mesh.position, player.mesh.position);
          if (toBall.length() < 0.1) toBall.set(1, 0, 0);
          toBall.normalize();
          // Add vertical component based on power
          toBall.y = lerp(0.1, 0.5, this.powerBarValue);
          let passPower = lerp(16, 36, this.powerBarValue);
          this.ball.velocity.x = toBall.x * passPower;
          this.ball.velocity.y = toBall.y * passPower;
          this.ball.velocity.z = toBall.z * passPower;
          if (Math.sqrt(this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2) > 40) {
            let scale = 40 / Math.sqrt(this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2);
            this.ball.velocity.x *= scale;
            this.ball.velocity.z *= scale;
          }
          this.ball.spin = randRange(-0.5, 0.5);
          player.cooldown = 0.5;
          if (this.sounds.pass) this.sounds.pass.play();
          // Hide power bar after kick
          this._hidePowerBarUI();
        }
        // Player-ball collision: ball bounces off players
        _handlePlayerBallCollisions() {
          for (const team of this.teams) {
            for (const player of team.players) {
              const dist = player.mesh.position.distanceTo(
                this.ball.mesh.position
              );
              if (dist < PLAYER_RADIUS + BALL_RADIUS + 0.5) {
                // Ball bounces off player
                let collisionDir = new THREE.Vector3()
                  .subVectors(this.ball.mesh.position, player.mesh.position)
                  .normalize();
                let impact = 12;
                this.ball.velocity.addScaledVector(collisionDir, impact);
                this.ball.spin += randRange(-0.2, 0.2);
                // Slightly push player back
                player.velocity.addScaledVector(collisionDir.negate(), 4);
              }
            }
          }
        }

        // Basic AI movement for CPU team
        _handleCPUMovement(dt) {
          let cpuTeam = this.teams[1];
          for (let i = 0; i < TEAM_SIZE; ++i) {
            let cpu = cpuTeam.players[i];
            if (cpu.cooldown <= 0 && !cpu._tackledTimer) {
              // Forwards and midfielders attack, defenders hold position
              let role = i === 0 ? "gk" : i < 5 ? "def" : i < 9 ? "mid" : "fwd";
              if (role === "fwd" || role === "mid") {
                // Attack: move towards ball, then towards user goal
                let toBall = new THREE.Vector3().subVectors(this.ball.mesh.position, cpu.mesh.position);
                toBall.y = 0;
                if (toBall.length() > 0.1) toBall.normalize();
                // If close to ball, move towards user goal
                const distToBall = cpu.mesh.position.distanceTo(this.ball.mesh.position);
                if (distToBall < 2.5) {
                  let toGoal = new THREE.Vector3(-FIELD_LENGTH / 2 + GOAL_DEPTH, 0, 0).sub(cpu.mesh.position);
                  if (toGoal.length() > 0.1) toGoal.normalize();
                  cpu.move(toGoal, dt);
                  // Try to shoot if very close
                  if (distToBall < PLAYER_RADIUS + BALL_RADIUS + 1.2) {
                    let shootDir = new THREE.Vector3(-1, lerp(0.1, 0.7, Math.random()), 0);
                    let shootPower = lerp(18, 36, Math.random());
                    this.ball.velocity.copy(shootDir.multiplyScalar(shootPower));
                    this.ball.spin += randRange(-0.5, 0.5);
                    cpu.cooldown = 1.2;
                    if (this.sounds.kick) this.sounds.kick.play();
                  }
                } else {
                  cpu.move(toBall, dt);
                }
              } else if (role === "def") {
                // Defenders: hold position, move towards ball if close
                let homeX = this.idx === 1 ? FIELD_LENGTH / 2 - 18 : -FIELD_LENGTH / 2 + 18;
                let homeZ = cpu.mesh.position.z;
                let toHome = new THREE.Vector3(homeX, 0, homeZ).sub(cpu.mesh.position);
                if (toHome.length() > 0.1) toHome.normalize();
                cpu.move(toHome, dt);
                // If ball is close, move towards ball
                const distToBall = cpu.mesh.position.distanceTo(this.ball.mesh.position);
                if (distToBall < 6) {
                  let toBall = new THREE.Vector3().subVectors(this.ball.mesh.position, cpu.mesh.position);
                  toBall.y = 0;
                  if (toBall.length() > 0.1) toBall.normalize();
                  cpu.move(toBall, dt);
                }
              } else {
                // Goalkeeper: stay near goal
                let gkX = FIELD_LENGTH / 2 - 6;
                let gkZ = 0;
                let toHome = new THREE.Vector3(gkX, 0, gkZ).sub(cpu.mesh.position);
                if (toHome.length() > 0.1) toHome.normalize();
                cpu.move(toHome, dt);
              }
            }
          }
        }

        _handleShoot(player) {
          let nearGoal = player.mesh.position.x > FIELD_LENGTH / 2 - 24;
          let shootDir = this.safe(
            () => this.powerBarDir.clone(),
            new THREE.Vector3(1, 0, 0)
          );
          if (shootDir.length() < 0.1) shootDir.set(1, 0, 0);
          // Ensure shootDir is normalized in x and z only
          let flatDir = shootDir.clone();
          flatDir.y = 0;
          if (flatDir.length() > 0.1) flatDir.normalize();
          shootDir.x = flatDir.x;
          shootDir.z = flatDir.z;
          shootDir.normalize();
          // Add vertical lift for shots
          shootDir.y = lerp(0.2, 1.2, this.powerBarValue);
          if (nearGoal) {
            let shootPower = lerp(28, 60, this.powerBarValue);
            this.ball.velocity.x = shootDir.x * shootPower;
            this.ball.velocity.y = shootDir.y * shootPower;
            this.ball.velocity.z = shootDir.z * shootPower;
            if (
              Math.sqrt(this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2) >
              60
            ) {
              let scale =
                60 /
                Math.sqrt(
                  this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2
                );
              this.ball.velocity.x *= scale;
              this.ball.velocity.z *= scale;
            }
            this.ball.spin = randRange(-1, 1) * this.powerBarValue;
            player.cooldown = 0.7;
            if (this.sounds.kick) this.sounds.kick.play();
          } else {
            let shootPower = lerp(18, 40, this.powerBarValue);
            this.ball.velocity.x = shootDir.x * shootPower;
            this.ball.velocity.y = shootDir.y * shootPower;
            this.ball.velocity.z = shootDir.z * shootPower;
            if (
              Math.sqrt(this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2) >
              45
            ) {
              let scale =
                45 /
                Math.sqrt(
                  this.ball.velocity.x ** 2 + this.ball.velocity.z ** 2
                );
              this.ball.velocity.x *= scale;
              this.ball.velocity.z *= scale;
            }
            this.ball.spin = randRange(-0.7, 0.7) * this.powerBarValue;
            player.cooldown = 0.5;
            if (this.sounds.kick) this.sounds.kick.play();
          }
        }
        // Returns {teamIdx, playerIdx} if a player is in possession, else null
        getPossession() {
          this.debugFunctionEntry("getPossession");
          let minDist = Infinity,
            poss = null;
          for (const [tIdx, team] of this.teams.entries()) {
            for (const [pIdx, player] of team.players.entries()) {
              let d = player.mesh.position.distanceTo(this.ball.mesh.position);
              if (d < PLAYER_RADIUS + BALL_RADIUS + 1.2 && d < minDist) {
                minDist = d;
                poss = { teamIdx: tIdx, playerIdx: pIdx };
              }
            }
<<<<<<< Updated upstream
<<<<<<< Updated upstream
            return poss;
        }
        constructor(userColor = 0xf39c12, cpuColor = 0xe74c3c) {
            this.debugFunctionEntry('constructor');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0, 120, 180);
            this.camera.lookAt(0, 0, 0);
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x1e824c);
            this.renderer.shadowMap.enabled = true;
            document.body.appendChild(this.renderer.domElement);
            window.addEventListener('resize', () => this.onWindowResize());

            // Lighting
            this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 120, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 10;
            dirLight.shadow.camera.far = 300;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            this.scene.add(dirLight);

            // Field
            this.field = new Field(this.scene);

            // Ball
            this.ball = new Ball(this.scene);

            // Teams (use selected colors)
            this.teams = [
                new Team(this.scene, 0, userColor, 'You'),
                new Team(this.scene, 1, cpuColor, 'CPU')
            ];
            this.teams[0].isUser = true;
            this.teams[1].isUser = false;

            // Game State
            this.score = [0, 0];
            this.time = GAME_TIME;
            this.state = 'playing';
            this.lastGoalTeam = null;
            this.selectedPlayerIdx = 0;

            // Controls
            this.controls = {};
            document.addEventListener('keydown', e => this.onKeyDown(e));
            document.addEventListener('keyup', e => this.onKeyUp(e));

            // Sound
            this.sounds = this.initSounds();
            this.muted = false;
            document.getElementById('muteBtn').onclick = () => this.toggleMute();

            // Crowd sound with fallback and error handling
            this.crowdAudio = new Audio();
            this.crowdAudio.loop = true;
            this.crowdAudio.volume = 0.18;
            // Try main source
            this.crowdAudio.src = 'https://cdn.pixabay.com/audio/2022/10/16/audio_12b6b7b2b2.mp3';
            this.crowdAudio.onerror = () => {
                // Fallback to another MP3 crowd sound
                this.crowdAudio.src = 'https://cdn.freesound.org/previews/456/456119_5121236-lq.mp3';
                this.crowdAudio.load();
                this.crowdAudio.play().catch(() => {});
            };
            this.crowdAudio.play().catch(() => {});

            // Weather
            this.initWeather();

            // Replay
            this.replayBuffer = [];
            this.isReplaying = false;
            document.getElementById('replayBtn').onclick = () => this.startReplay();

            // UI
            this.updateUI();
            this.resetPositions();
            let user = this.teams[0].players[0];
            let kickoffPos = user.mesh.position.clone().add(new THREE.Vector3(PLAYER_RADIUS + BALL_RADIUS + 0.5, 0, 0));
            this.ball.setPosition(kickoffPos.x, this.ball.mesh.position.y, kickoffPos.z);
            this.ball.velocity.set(8, 0, 0);
            this.state = 'playing';
            this.hideOverlay();
            if (this.sounds.melody) this.sounds.melody.play();
            this.lastFrame = performance.now();
            this.animate();
=======
          }
          return poss;
>>>>>>> Stashed changes
=======
          }
          return poss;
>>>>>>> Stashed changes
        }
        initSounds() {
          this.debugFunctionEntry("initSounds");
          // Drum-like web audio API sounds and a melody
          const ctx = window.AudioContext ? new window.AudioContext() : null;
          function drum(type, dur, vol = 0.2, freq = 120) {
            if (!ctx) return { play: () => {} };
            return {
              play: () => {
                if (window.game && window.game.muted) return;
                let o = ctx.createOscillator();
                let g = ctx.createGain();
                let b = ctx.createBiquadFilter();
                o.type = type; // 'sine', 'triangle', 'square', 'sawtooth'
                o.frequency.setValueAtTime(freq, ctx.currentTime);
                // Pitch drop for drum effect
                o.frequency.linearRampToValueAtTime(
                  40,
                  ctx.currentTime + dur / 1000
                );
                g.gain.setValueAtTime(vol, ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(
                  0.001,
                  ctx.currentTime + dur / 1000
                );
                b.type = "lowpass";
                b.frequency.value = 800;
                o.connect(b).connect(g).connect(ctx.destination);
                o.start();
                o.stop(ctx.currentTime + dur / 1000);
              },
            };
          }
          // Little melody: array of [freq, duration(ms)]
          function melody(notes, vol = 0.13, type = "triangle", tempo = 1.0) {
            if (!ctx) return { play: () => {} };
            return {
              play: () => {
                if (window.game && window.game.muted) return;
                let now = ctx.currentTime;
                let t = now;
                for (const note of notes) {
                  let [freq, dur] = note;
                  let o = ctx.createOscillator();
                  let g = ctx.createGain();
                  o.type = type;
                  o.frequency.setValueAtTime(freq, t);
                  g.gain.setValueAtTime(vol, t);
                  g.gain.linearRampToValueAtTime(
                    0.001,
                    t + (dur / 1000) * tempo
                  );
                  o.connect(g).connect(ctx.destination);
                  o.start(t);
                  o.stop(t + (dur / 1000) * tempo);
                  t += (dur / 1000) * tempo;
                }
              },
            };
          }
          // Simple football-y tune
          const mainMelody = [
            [261.63, 180],
            [329.63, 180],
            [392.0, 180],
            [329.63, 180],
            [349.23, 180],
            [293.66, 180],
            [261.63, 320],
          ];
          return {
            goal: drum("triangle", 320, 0.22, 180), // deeper drum
            kick: drum("sine", 90, 0.13, 120), // soft kick drum
            pass: drum("triangle", 70, 0.1, 200), // snare-like
            whistle: drum("triangle", 420, 0.16, 400), // higher, short
            end: drum("sine", 900, 0.16, 80), // long, deep
            melody: melody(mainMelody, 0.13, "triangle", 1.0),
          };
        }
        toggleMute() {
          this.debugFunctionEntry("toggleMute");
          this.muted = !this.muted;
          document.getElementById("muteBtn").textContent = this.muted
            ? "ðŸ”‡"
            : "ðŸ”Š";
        }

        onWindowResize() {
          this.debugFunctionEntry("onWindowResize");
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        updateUI() {
          this.debugFunctionEntry("updateUI");
          // Update scoreboard in top-left corner
          let scoreboard = document.getElementById("scoreboard");
          if (!scoreboard) return;
          // Refactored to avoid nested template literals
          const scoreUser = `<span class="score-user">You</span><span id="score-user">${this.score[0]}</span>`;
          const scoreSeparator = `<span class="score-separator">-</span>`;
          const scoreCpu = `<span id="score-cpu">${this.score[1]}</span><span class="score-cpu">CPU</span>`;
          const scoreline = `<div id="scoreline" class="scoreline">${scoreUser}${scoreSeparator}${scoreCpu}</div>`;
          const timeInfo = `<span id="info">Time: <b>${Math.floor(
            this.time
          )}</b>s</span>`;
          const debugInfo = `<span id="debug"></span>`;
          scoreboard.innerHTML = scoreline + timeInfo + debugInfo;
        }
        showOverlay(msg) {
          this.debugFunctionEntry("showOverlay", { msg });
          let overlay = document.getElementById("overlay");
          if (overlay) {
            overlay.innerHTML = msg;
            overlay.style.display = "flex";
          }
        }
        hideOverlay() {
          this.debugFunctionEntry("hideOverlay");
          let overlay = document.getElementById("overlay");
          if (overlay) overlay.style.display = "none";
        }
        // Debug overlay removed
        debug(msg) {
          this.debugFunctionEntry("debug", { msg });
          // No-op: debug overlay removed
        }

        onKeyDown(e) {
<<<<<<< Updated upstream
<<<<<<< Updated upstream
            this.debugFunctionEntry('onKeyDown', { key: e.key });
            this.controls[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'r') this.startReplay();
            if (e.key.toLowerCase() === 'm') this.toggleMute();
            // Player switch with Tab
            if (e.key === 'Tab') {
                e.preventDefault();
                this.selectedPlayerIdx = (this.selectedPlayerIdx + 1) % TEAM_SIZE;
            }
            // Start power bar on space down (if not already active)
            if (e.key === ' ' && !this.powerBarActive && this.state === 'playing') {
                this.powerBarActive = true;
                this.powerBarValue = 0;
                this.powerBarType = null;
            }
        }
        animate() {
            try {
                // Calculate time delta
                const now = performance.now();
                const dt = this.lastFrame ? Math.min((now - this.lastFrame) / 1000, 0.08) : 1/60;
                this.lastFrame = now;

                // Process input and update game objects
                this.handleInput(dt);
                // Update all players
                for (let team of this.teams) {
                    for (let player of team.players) {
                        player.update(dt);
                    }
                }
                // Update ball
                this.ball.update();

                // Goal detection
                if (Math.abs(this.ball.mesh.position.x) > FIELD_LENGTH/2 - GOAL_DEPTH && Math.abs(this.ball.mesh.position.z) < GOAL_WIDTH/2) {
                    let teamIdx = this.ball.mesh.position.x > 0 ? 0 : 1;
                    if (this.state === 'playing') {
                        this.scoreGoal(teamIdx);
                        if (this.sounds.whistle) this.sounds.whistle.play();
                    }
                }

                // Camera logic
                let camTarget, camHeight = 60, camDist = 80;
                if (this.state === 'replay') {
                    camTarget = new THREE.Vector3(this.ball.mesh.position.x, camHeight, this.ball.mesh.position.z + camDist);
                } else {
                    let player = this.teams[0].players[this.selectedPlayerIdx];
                    camTarget = new THREE.Vector3(player.mesh.position.x, camHeight, player.mesh.position.z + camDist);
                }
                // Dynamic zoom based on ball speed
                let ballSpeed = this.ball.velocity.length();
                camHeight = 60 + Math.min(ballSpeed * 2.5, 40);
                camDist = 80 + Math.min(ballSpeed * 2.5, 40);
                camTarget.y = camHeight;
                camTarget.z = (this.state === 'replay') ? this.ball.mesh.position.z + camDist : this.teams[0].players[this.selectedPlayerIdx].mesh.position.z + camDist;
                this.camera.position.lerp(camTarget, 0.08);
                this.camera.lookAt(this.ball.mesh.position.x, 0, this.ball.mesh.position.z);
                this.drawLabels();
                this.logDebug('Ball: ' + this.ball.mesh.position.x.toFixed(1) + ',' + this.ball.mesh.position.z.toFixed(1) + '  Vel:' + this.ball.velocity.length().toFixed(2), 'ball');
                this.renderer.render(this.scene, this.camera);
            } catch (e) {
                this.showOverlay('Error: ' + e.message);
                throw e;
            }
            requestAnimationFrame(() => this.animate());
        }
        scoreGoal(teamIdx) {
            this.debugFunctionEntry('scoreGoal', { teamIdx });
            this.logDebug('scoreGoal called, teamIdx=' + teamIdx);
            this.score[teamIdx]++;
            this.updateUI();
            this.state = 'goal';
            let color = '#fff';
            let player = this.teams[teamIdx] && this.teams[teamIdx].players && this.teams[teamIdx].players[0];
            if (player && player.mesh && player.mesh.material && player.mesh.material.color && typeof player.mesh.material.color.getStyle === 'function') {
                color = player.mesh.material.color.getStyle();
            }
            this.showOverlay(`<span style='color:${color};font-weight:bold;font-size:2em;'>${teamIdx === 0 ? 'You' : 'CPU'} scored!</span><br><span style='font-size:1.2em;'>ðŸŽ‰ GOAL! ðŸŽ‰</span>`);
            if (this.sounds.goal) this.sounds.goal.play();
            // Play crowd cheer
            if (this.crowdAudio) {
                this.crowdAudio.currentTime = 0;
                this.crowdAudio.volume = 0.45;
                setTimeout(() => { this.crowdAudio.volume = 0.18; }, 1800);
            }
            if (this.sounds.melody) this.sounds.melody.play();
            document.getElementById('replayBtn').style.display = 'inline-block';
            this.ball.velocity.set(0,0,0);
            for (let t of this.teams) for (let p of t.players) p.cooldown = 1;
            setTimeout(() => {
                this.resetPositions();
                this.hideOverlay();
                this.state = 'playing';
                document.getElementById('replayBtn').style.display = 'none';
            }, 2000);
=======
          this.debugFunctionEntry("onKeyDown", { key: e.key });
          this.controls[e.key.toLowerCase()] = true;
          if (e.key.toLowerCase() === "r") this.startReplay();
          if (e.key.toLowerCase() === "m") this.toggleMute();
          // Start power bar on space down (if not already active)
          if (
            e.key === " " &&
            !this.powerBarActive &&
            this.state === "playing"
          ) {
            this.powerBarActive = true;
            this.powerBarValue = 0;
            this.powerBarType = null;
          }
        }
=======
          this.debugFunctionEntry("onKeyDown", { key: e.key });
          this.controls[e.key.toLowerCase()] = true;
          if (e.key.toLowerCase() === "r") this.startReplay();
          if (e.key.toLowerCase() === "m") this.toggleMute();
          // Start power bar on space down (if not already active)
          if (
            e.key === " " &&
            !this.powerBarActive &&
            this.state === "playing"
          ) {
            this.powerBarActive = true;
            this.powerBarValue = 0;
            this.powerBarType = null;
          }
        }
>>>>>>> Stashed changes
        onKeyUp(e) {
          this.debugFunctionEntry("onKeyUp", { key: e.key });
          this.controls[e.key.toLowerCase()] = false;
          // On space up, trigger pass/shoot/tackle if power bar was active
          if (
            e.key === " " &&
            this.powerBarActive &&
            this.state === "playing"
          ) {
            this.handlePowerBarAction();
            this.powerBarActive = false;
            this.powerBarValue = 0;
            this.powerBarType = null;
          }
        }

        resetPositions() {
          this.debugFunctionEntry("resetPositions");
          // Place ball at center
          this.ball.setPosition(0, BALL_RADIUS + 1, 0);
          this.ball.velocity.set(0, 0, 0);
          // Place players
          this.teams[0].resetPositions(-FIELD_LENGTH / 4);
          this.teams[1].resetPositions(FIELD_LENGTH / 4);
          this.selectedPlayerIdx = 0;
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
        }

        switchPlayer() {
          this.debugFunctionEntry("switchPlayer");
          // Switch to closest player to ball
          let minDist = 9999,
            idx = 0;
          for (let i = 0; i < TEAM_SIZE; ++i) {
            let d = this.teams[0].players[i].mesh.position.distanceTo(
              this.ball.mesh.position
            );
            if (d < minDist) {
              minDist = d;
              idx = i;
            }
          }
          this.selectedPlayerIdx = idx;
        }

        handleInput(dt) {
          this.debugFunctionEntry("handleInput", { dt });
          this.logDebug(
            "[Input] dt=" +
              dt.toFixed(4) +
              " | SelectedPlayerIdx=" +
              this.selectedPlayerIdx +
              " | PlayerPos=" +
              this.teams[0].players[
                this.selectedPlayerIdx
              ].mesh.position.x.toFixed(2) +
              "," +
              this.teams[0].players[
                this.selectedPlayerIdx
              ].mesh.position.z.toFixed(2) +
              " | PlayerVel=" +
              (this.teams[0].players[this.selectedPlayerIdx].velocity
                ? this.teams[0].players[this.selectedPlayerIdx].velocity
                    .length()
                    .toFixed(2)
                : "n/a") +
              " | Cooldown=" +
              this.teams[0].players[this.selectedPlayerIdx].cooldown.toFixed(
                2
              ) +
              " | BallPos=" +
              this.ball.mesh.position.x.toFixed(2) +
              "," +
              this.ball.mesh.position.z.toFixed(2) +
              " | BallVel=" +
              this.ball.velocity.length().toFixed(2) +
              " | BallSpin=" +
              this.ball.spin.toFixed(2)
          );
          // --- Throw-in Controls ---
          if (this.state === "throw-in" && this.throwInActive) {
            this._handleThrowIn(dt);
            return;
          }
          // --- User Player Movement ---
          if (this.state === "playing") {
            this._handleUserMovement(dt);
          }
        }

        _handleThrowIn(dt) {
          if (this.throwInTeam === this.teams[0]) {
            this._selectNearestUserPlayerForThrowIn();
          }
          let team = this.throwInTeam;
          let idx = team === this.teams[0] ? this.selectedPlayerIdx : 0;
          let player = team.players[idx];
          this._showPowerBarUI();
          this.powerBarValue = Math.min(this.powerBarValue + dt * 2.2, 1);
          let dir = this._getInputDirection();
          if (this.powerBarDir) {
            this.powerBarDir.copy(dir);
          } else {
            this.powerBarDir = dir.clone();
          }
          this._updatePowerBarUI();
          if (!this.controls[" "]) {
            this._executeThrowIn(player);
          }
        }

        _selectNearestUserPlayerForThrowIn() {
          let minDist = Infinity,
            idx = 0;
          for (let [i, player] of this.teams[0].players.entries()) {
            let d = player.mesh.position.distanceTo(this.throwInPos);
            if (d < minDist) {
              minDist = d;
              idx = i;
            }
          }
          this.selectedPlayerIdx = idx;
        }

        _showPowerBarUI() {
          let pb = document.getElementById("powerbar-container");
          if (pb) pb.style.display = "block";
          let fill = document.getElementById("powerbar-fill");
          if (fill) fill.style.width = (this.powerBarValue * 100).toFixed(1) + "%";
          let label = document.getElementById("powerbar-label");
          if (label) label.textContent = "Power: " + Math.round(this.powerBarValue * 100) + "%";
        }
        _hidePowerBarUI() {
          let pb = document.getElementById("powerbar-container");
          if (pb) pb.style.display = "none";
        }

        _executeThrowIn(player) {
          let pb = document.getElementById("powerbar-container");
          let throwDir = this.powerBarDir.clone();
          if (throwDir.length() < 0.1) throwDir.set(1, 0, 0);
          throwDir.normalize();
          let throwPower = lerp(18, 38, this.powerBarValue);
          let curve = lerp(0, 1.2, this.powerBarValue);
          let curveVec = new THREE.Vector3(
            -throwDir.z,
            0,
            throwDir.x
          ).multiplyScalar(curve);
          let finalDir = throwDir.clone().add(curveVec).normalize();
          this.ball.velocity.copy(finalDir.multiplyScalar(throwPower));
          this.ball.spin = curve * 2;
          player.cooldown = 0.5;
          this.throwInActive = false;
          this.state = "playing";
          if (this.sounds.pass) this.sounds.pass.play();
          if (pb) pb.style.display = "none";
        }

        _handleUserMovement(dt) {
          let player = this.teams[0].players[this.selectedPlayerIdx];
          if (player.cooldown <= 0 && !player._tackledTimer) {
            let moveDir = this._getInputDirectionForMovement();
            player.move(moveDir, dt);
            this._handleDribble(player, moveDir, dt);
          }
        }

        _getInputDirectionForMovement() {
          let moveDir = new THREE.Vector3();
          if (this.controls["arrowup"] || this.controls["w"]) moveDir.z -= 1;
          if (this.controls["arrowdown"] || this.controls["s"]) moveDir.z += 1;
          if (this.controls["arrowleft"] || this.controls["a"]) moveDir.x -= 1;
          if (this.controls["arrowright"] || this.controls["d"]) moveDir.x += 1;
          if (isNaN(moveDir.x) || isNaN(moveDir.y) || isNaN(moveDir.z))
            moveDir.set(0, 0, 0);
          if (moveDir.length() > 0.1) moveDir.normalize();
          return moveDir;
        }

        _handleDribble(player, moveDir, dt) {
          const distToBall = player.mesh.position.distanceTo(
            this.ball.mesh.position
          );
          if (
            distToBall < PLAYER_RADIUS + BALL_RADIUS + 1.2 &&
            moveDir.length() > 0.1
          ) {
            let dribblePower = 18 * dt;
            let ballDir = moveDir.clone();
            ballDir.y = 0; // keep ball on ground for dribble
            if (ballDir.length() > 0.1) ballDir.normalize();
            // Set ball velocity to follow player, not accumulate
            this.ball.velocity.x = ballDir.x * dribblePower;
            this.ball.velocity.z = ballDir.z * dribblePower;
            this.ball.velocity.y = 0; // keep ball on ground
            this.ball.spin += (Math.random() - 0.5) * 0.04;
          }
        }
      }

      class Field {
        constructor(scene) {
          this.scene = scene;
          this.mesh = this.createField();
          this.lines = this.createLines();
          this.goalposts = this.createGoalposts();
          this.scene.add(this.mesh);
          this.scene.add(this.lines);
          this.scene.add(this.goalposts);
        }

        createField() {
          const fieldGeometry = new THREE.BoxGeometry(
            FIELD_LENGTH,
            1,
            FIELD_WIDTH
          );
          const fieldMaterial = new THREE.MeshPhongMaterial({
            color: 0x007700,
          });
          const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
          fieldMesh.receiveShadow = true;
          fieldMesh.position.y = 0; // Set pitch at y=0
          return fieldMesh;
        }

        createLines() {
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
          const lines = new THREE.Group();
          // Outline
          lines.add(
            this.createLine(
              [-FIELD_LENGTH / 2, 0, -FIELD_WIDTH / 2],
              [FIELD_LENGTH / 2, 0, -FIELD_WIDTH / 2],
              lineMaterial
            )
          );
          lines.add(
            this.createLine(
              [FIELD_LENGTH / 2, 0, -FIELD_WIDTH / 2],
              [FIELD_LENGTH / 2, 0, FIELD_WIDTH / 2],
              lineMaterial
            )
          );
          lines.add(
            this.createLine(
              [FIELD_LENGTH / 2, 0, FIELD_WIDTH / 2],
              [-FIELD_LENGTH / 2, 0, FIELD_WIDTH / 2],
              lineMaterial
            )
          );
          lines.add(
            this.createLine(
              [-FIELD_LENGTH / 2, 0, FIELD_WIDTH / 2],
              [-FIELD_LENGTH / 2, 0, -FIELD_WIDTH / 2],
              lineMaterial
            )
          );
          // Halfway line
          lines.add(
            this.createLine(
              [0, 0, -FIELD_WIDTH / 2],
              [0, 0, FIELD_WIDTH / 2],
              lineMaterial
            )
          );
          // Center circle
          const circleGeometry = new THREE.CircleGeometry(9.15, 32);
          const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
          });
          const centerCircle = new THREE.Mesh(circleGeometry, circleMaterial);
          centerCircle.position.set(0, 0.1, 0);
          centerCircle.rotation.x = -Math.PI / 2;
          lines.add(centerCircle);
          return lines;
        }

        createLine(start, end, material) {
          const points = [
            new THREE.Vector3(...start),
            new THREE.Vector3(...end),
          ];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          return new THREE.Line(geometry, material);
        }

        createGoalposts() {
          const posts = new THREE.Group();
          const postMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
          // User goal
          posts.add(this.createGoalpost(-FIELD_LENGTH / 2 + 1, postMaterial));
          posts.add(
            this.createGoalpost(-FIELD_LENGTH / 2 + 1, postMaterial, true)
          );
          // CPU goal
          posts.add(this.createGoalpost(FIELD_LENGTH / 2 - 1, postMaterial));
          posts.add(
            this.createGoalpost(FIELD_LENGTH / 2 - 1, postMaterial, true)
          );
          return posts;
        }

        createGoalpost(x, material, isTop = false) {
          const goalpostGeometry = new THREE.BoxGeometry(
            GOAL_DEPTH,
            GOAL_HEIGHT,
            GOAL_WIDTH
          );
          const goalpostMesh = new THREE.Mesh(goalpostGeometry, material);
          goalpostMesh.castShadow = true;
          goalpostMesh.position.set(x, GOAL_HEIGHT / 2, 0);
          if (isTop) {
            goalpostMesh.rotation.z = Math.PI / 2;
            goalpostMesh.position.y = GOAL_WIDTH / 2;
          }
          return goalpostMesh;
        }
      }

      class Ball {
        constructor(scene) {
          this.scene = scene;
          this.mesh = this.createBall();
          this.velocity = new THREE.Vector3();
          this.spin = 0;
          this.scene.add(this.mesh);
        }

        createBall() {
          const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
          const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
          const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
          ballMesh.castShadow = true;
          return ballMesh;
        }

        setPosition(x, y, z) {
          this.mesh.position.set(x, y, z);
        }

        update() {
<<<<<<< Updated upstream
<<<<<<< Updated upstream
            this.mesh.position.add(this.velocity.clone().multiplyScalar(1/60));
            this.velocity.y -= 0.2; // Gravity
            this.velocity.x *= 0.99;
            this.velocity.z *= 0.99;
            this.mesh.rotation.y += this.spin;
            this.spin *= 0.98;
            // Ball boundary bounce
            if (this.mesh.position.x < -FIELD_LENGTH/2 + BALL_RADIUS) {
                this.mesh.position.x = -FIELD_LENGTH/2 + BALL_RADIUS;
                this.velocity.x *= -0.7;
            }
            if (this.mesh.position.x > FIELD_LENGTH/2 - BALL_RADIUS) {
                this.mesh.position.x = FIELD_LENGTH/2 - BALL_RADIUS;
                this.velocity.x *= -0.7;
            }
            if (this.mesh.position.z < -FIELD_WIDTH/2 + BALL_RADIUS) {
                this.mesh.position.z = -FIELD_WIDTH/2 + BALL_RADIUS;
                this.velocity.z *= -0.7;
            }
            if (this.mesh.position.z > FIELD_WIDTH/2 - BALL_RADIUS) {
                this.mesh.position.z = FIELD_WIDTH/2 - BALL_RADIUS;
                this.velocity.z *= -0.7;
            }
            // Clamp Y to ground
            if (this.mesh.position.y < 0) {
                this.mesh.position.y = 0;
                this.velocity.y = 0;
            }
=======
=======
>>>>>>> Stashed changes
          this.mesh.position.add(this.velocity.clone().multiplyScalar(1 / 60));
          this.velocity.y -= 0.2; // Gravity
          this.velocity.x *= 0.99;
          this.velocity.z *= 0.99;
          this.mesh.rotation.y += this.spin;
          this.spin *= 0.98;
          // Clamp ball to stay above ground
          if (this.mesh.position.y < BALL_RADIUS) {
            this.mesh.position.y = BALL_RADIUS;
            this.velocity.y = 0;
          }
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
        }
      }

      class Team {
        constructor(scene, idx, color, name) {
          this.scene = scene;
          this.idx = idx;
          this.color = color;
          this.name = name;
          this.players = [];
          this.createPlayers();
        }

        createPlayers() {
          // Arrange players in a basic 4-4-2 formation
          const formation = [
            // Goalkeeper
            { x: this.idx === 0 ? -FIELD_LENGTH / 2 + 6 : FIELD_LENGTH / 2 - 6, z: 0 },
            // Defenders
            { x: this.idx === 0 ? -FIELD_LENGTH / 2 + 18 : FIELD_LENGTH / 2 - 18, z: -20 },
            { x: this.idx === 0 ? -FIELD_LENGTH / 2 + 18 : FIELD_LENGTH / 2 - 18, z: 0 },
            { x: this.idx === 0 ? -FIELD_LENGTH / 2 + 18 : FIELD_LENGTH / 2 - 18, z: 20 },
            { x: this.idx === 0 ? -FIELD_LENGTH / 2 + 26 : FIELD_LENGTH / 2 - 26, z: -10 },
            // Midfielders
            { x: 0, z: -25 },
            { x: 0, z: 0 },
            { x: 0, z: 25 },
            { x: this.idx === 0 ? -10 : 10, z: -10 },
            { x: this.idx === 0 ? -10 : 10, z: 10 },
            // Forwards
            { x: this.idx === 0 ? FIELD_LENGTH / 2 - 18 : -FIELD_LENGTH / 2 + 18, z: 0 }
          ];
          for (let i = 0; i < TEAM_SIZE; ++i) {
            let pos = formation[i] || { x: 0, z: 0 };
            let player = new Player(this.scene, this.idx, this.color, i);
            player.setPosition(pos.x, PLAYER_RADIUS, pos.z);
            this.players.push(player);
          }
        }

        resetPositions(offset) {
          for (let i = 0; i < TEAM_SIZE; ++i) {
            let player = this.players[i];
            player.setPosition(offset + i * 8, 0, 0);
            player.velocity.set(0, 0, 0);
            player.cooldown = 0;
            player._tackledTimer = 0;
          }
        }
      }

      class Player {
        constructor(scene, teamIdx, color, playerIdx) {
<<<<<<< Updated upstream
<<<<<<< Updated upstream
            this.scene = scene;
            this.teamIdx = teamIdx;
            this.color = color;
            this.playerIdx = playerIdx;
            this.mesh = this.createPlayer();
            this.velocity = new THREE.Vector3();
            this.cooldown = 0;
            this._tackledTimer = 0;
            this.stamina = 1.0; // 1.0 = full, 0 = exhausted
            scene.add(this.mesh);
        }

        createPlayer() {
            // Use animated human model (Soldier.glb from Three.js examples)
            const group = new THREE.Group();
            const loader = new GLTFLoader();
            const modelUrl = 'https://threejs.org/examples/models/gltf/Soldier.glb';
            loader.load(modelUrl, (gltf) => {
                const model = gltf.scene;
                model.scale.set(2.2, 2.2, 2.2);
                model.traverse((obj) => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.material = obj.material.clone();
                        if (this.color && obj.material.color) {
                            obj.material.color.set(this.color);
                        }
                    }
                });
                group.add(model);
                // Animation
                this.mixer = new THREE.AnimationMixer(model);
                if (gltf.animations && gltf.animations.length > 0) {
                    this.action = this.mixer.clipAction(gltf.animations[0]);
                    this.action.play();
                }
            });
            return group;
=======
          this.scene = scene;
          this.teamIdx = teamIdx;
          this.color = color;
          this.playerIdx = playerIdx;
          this.mesh = this.createPlayer();
          this.velocity = new THREE.Vector3();
          this.cooldown = 0;
          this._tackledTimer = 0;
          scene.add(this.mesh);
        }

        createPlayer() {
=======
          this.scene = scene;
          this.teamIdx = teamIdx;
          this.color = color;
          this.playerIdx = playerIdx;
          this.mesh = this.createPlayer();
          this.velocity = new THREE.Vector3();
          this.cooldown = 0;
          this._tackledTimer = 0;
          scene.add(this.mesh);
        }

        createPlayer() {
>>>>>>> Stashed changes
          // Simple humanoid: body (cylinder), head (sphere), legs (cylinders), arms (cylinders)
          const group = new THREE.Group();
          // Body
          const bodyGeom = new THREE.CylinderGeometry(PLAYER_RADIUS * 0.7, PLAYER_RADIUS, PLAYER_HEIGHT * 0.6, 8);
          const bodyMat = new THREE.MeshPhongMaterial({ color: this.color });
          const body = new THREE.Mesh(bodyGeom, bodyMat);
          body.position.y = PLAYER_HEIGHT * 0.6 / 2;
          group.add(body);
          // Head
          const headGeom = new THREE.SphereGeometry(PLAYER_RADIUS * 0.6, 8, 8);
          const headMat = new THREE.MeshPhongMaterial({ color: 0xffe0bd });
          const head = new THREE.Mesh(headGeom, headMat);
          head.position.y = PLAYER_HEIGHT * 0.6 + PLAYER_RADIUS * 0.6;
          group.add(head);
          // Legs
          for (let i = -1; i <= 1; i += 2) {
            const legGeom = new THREE.CylinderGeometry(PLAYER_RADIUS * 0.25, PLAYER_RADIUS * 0.25, PLAYER_HEIGHT * 0.4, 6);
            const legMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const leg = new THREE.Mesh(legGeom, legMat);
            leg.position.x = i * PLAYER_RADIUS * 0.3;
            leg.position.y = PLAYER_HEIGHT * 0.2;
            group.add(leg);
          }
          // Arms
          for (let i = -1; i <= 1; i += 2) {
            const armGeom = new THREE.CylinderGeometry(PLAYER_RADIUS * 0.18, PLAYER_RADIUS * 0.18, PLAYER_HEIGHT * 0.35, 6);
            const armMat = new THREE.MeshPhongMaterial({ color: this.color });
            const arm = new THREE.Mesh(armGeom, armMat);
            arm.position.x = i * PLAYER_RADIUS * 0.7;
            arm.position.y = PLAYER_HEIGHT * 0.5;
            arm.rotation.z = Math.PI / 4 * i;
            group.add(arm);
          }
          group.castShadow = true;
          group.receiveShadow = true;
          return group;
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
        }

        setPosition(x, y, z) {
          this.mesh.position.set(x, y, z);
        }

        move(direction, dt) {
<<<<<<< Updated upstream
<<<<<<< Updated upstream
            // Stamina system: moving drains stamina, resting recovers
            const baseSpeed = 50;
            if (direction.length() > 0.1) {
                this.stamina = Math.max(0, this.stamina - dt * 0.18);
            } else {
                this.stamina = Math.min(1, this.stamina + dt * 0.12);
            }
            const speed = baseSpeed * (0.5 + 0.5 * this.stamina);
            let forward = new THREE.Vector3(0, 0, -1).applyEuler(this.mesh.rotation, 'XYZ');
            let right = new THREE.Vector3(1, 0, 0).applyEuler(this.mesh.rotation, 'XYZ');
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            let targetVel = new THREE.Vector3();
            targetVel.add(forward.multiplyScalar(direction.z * speed));
            targetVel.add(right.multiplyScalar(direction.x * speed));
            targetVel.y = this.velocity.y;
            this.velocity = targetVel;
            this.mesh.rotation.y = Math.atan2(-forward.x, forward.z);
        }

        update(dt=1/60) {
            if (this.cooldown > 0) this.cooldown -= dt;
            if (this._tackledTimer) {
                this._tackledTimer -= dt;
                if (this._tackledTimer <= 0) this._tackledTimer = 0;
            }
            // Only move in X/Z, keep Y at 0
            let pos = this.mesh.position.clone();
            pos.add(this.velocity.clone().multiplyScalar(dt));
            pos.y = 0;
            this.mesh.position.copy(pos);
            this.velocity.x *= 0.99;
            this.velocity.z *= 0.99;
            // Animate model
            if (this.mixer) this.mixer.update(dt);
=======
          const speed = 50;
          let moveVec = direction.clone();
          moveVec.y = 0;
          if (moveVec.length() > 0.1) moveVec.normalize();
          // Set velocity directly based on input
          this.velocity.x = moveVec.x * speed;
          this.velocity.z = moveVec.z * speed;
          // Y velocity is affected by gravity and tackles only
          // Optionally, rotate player to face movement direction
          if (moveVec.length() > 0.1) {
            this.mesh.rotation.y = Math.atan2(moveVec.x, moveVec.z);
          }
        }

        update() {
          if (this.cooldown > 0) this.cooldown -= 1 / 60;
          if (this._tackledTimer) {
            this._tackledTimer -= 1 / 60;
            if (this._tackledTimer <= 0) this._tackledTimer = 0;
          }
          this.mesh.position.add(this.velocity.clone().multiplyScalar(1 / 60));
          this.velocity.y -= 0.2; // Gravity
          this.velocity.x *= 0.99;
          this.velocity.z *= 0.99;
          // Clamp player to stay above ground
          if (this.mesh.position.y < PLAYER_RADIUS) {
            this.mesh.position.y = PLAYER_RADIUS;
            this.velocity.y = 0;
          }
>>>>>>> Stashed changes
        }
      }

<<<<<<< Updated upstream
    // --- Game Initialization ---
    // --- Main Menu UI ---
function showMainMenu() {
    let menu = document.createElement('div');
    menu.id = 'main-menu';
    menu.style.position = 'fixed';
    menu.style.left = '0';
    menu.style.top = '0';
    menu.style.width = '100vw';
    menu.style.height = '100vh';
    menu.style.background = 'rgba(30,40,60,0.93)';
    menu.style.display = 'flex';
    menu.style.flexDirection = 'column';
    menu.style.alignItems = 'center';
    menu.style.justifyContent = 'center';
    menu.style.zIndex = '9999';
    menu.innerHTML = `
        <div style="background:#222b;padding:32px 38px 28px 38px;border-radius:18px;box-shadow:0 4px 32px #000a;min-width:320px;display:flex;flex-direction:column;align-items:center;">
            <h1 style='color:#fff;margin-bottom:18px;font-size:2.1em;'>Football Game</h1>
            <div style='margin-bottom:18px;'>
                <label style='color:#fff;font-size:1.1em;'>Your Team Colour: </label>
                <input id='userColor' type='color' value='#f39c12' style='width:40px;height:32px;border:none;margin-left:8px;vertical-align:middle;'>
            </div>
            <div style='margin-bottom:24px;'>
                <label style='color:#fff;font-size:1.1em;'>CPU Team Colour: </label>
                <input id='cpuColor' type='color' value='#e74c3c' style='width:40px;height:32px;border:none;margin-left:8px;vertical-align:middle;'>
            </div>
            <button id='startBtn' style='font-size:1.2em;padding:10px 32px;border-radius:8px;background:#27ae60;color:#fff;border:none;box-shadow:0 2px 8px #0006;cursor:pointer;'>Start Game</button>
        </div>
    `;
    document.body.appendChild(menu);
    document.getElementById('startBtn').onclick = function() {
        let userColor = document.getElementById('userColor').value;
        let cpuColor = document.getElementById('cpuColor').value;
        menu.remove();
        startGame(userColor, cpuColor);
    };
}

function startGame(userColor, cpuColor) {
    // Convert hex to int
    function hexToInt(hex) {
        if (typeof hex === 'string' && hex.startsWith('#')) {
            return parseInt(hex.slice(1), 16);
        }
        return hex;
    }
    window.game = new Game(hexToInt(userColor) || 0xf39c12, hexToInt(cpuColor) || 0xe74c3c);
}

window.onload = showMainMenu;
    </script>
=======
      // --- Game Initialization ---
      window.game = new Game();
>>>>>>> Stashed changes
    </script>
=======
          const speed = 50;
          let moveVec = direction.clone();
          moveVec.y = 0;
          if (moveVec.length() > 0.1) moveVec.normalize();
          // Set velocity directly based on input
          this.velocity.x = moveVec.x * speed;
          this.velocity.z = moveVec.z * speed;
          // Y velocity is affected by gravity and tackles only
          // Optionally, rotate player to face movement direction
          if (moveVec.length() > 0.1) {
            this.mesh.rotation.y = Math.atan2(moveVec.x, moveVec.z);
          }
        }

        update() {
          if (this.cooldown > 0) this.cooldown -= 1 / 60;
          if (this._tackledTimer) {
            this._tackledTimer -= 1 / 60;
            if (this._tackledTimer <= 0) this._tackledTimer = 0;
          }
          this.mesh.position.add(this.velocity.clone().multiplyScalar(1 / 60));
          this.velocity.y -= 0.2; // Gravity
          this.velocity.x *= 0.99;
          this.velocity.z *= 0.99;
          // Clamp player to stay above ground
          if (this.mesh.position.y < PLAYER_RADIUS) {
            this.mesh.position.y = PLAYER_RADIUS;
            this.velocity.y = 0;
          }
        }
      }

      // --- Game Initialization ---
      window.game = new Game();
    </script>
>>>>>>> Stashed changes
  </body>
</html>
